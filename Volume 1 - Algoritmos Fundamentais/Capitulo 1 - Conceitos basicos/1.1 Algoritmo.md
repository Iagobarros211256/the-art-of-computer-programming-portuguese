# 1.1 Algoritmo

A noção de um _algoritmo_ é fundamental para toda a programação de computadores, então devemos começar com uma análise cuidadosa desse conceito.

A própria palavra “algoritmo” é bastante interessante; à primeira vista, pode parecer que alguém pretendia escrever “logaritmo”, mas embaralhou as quatro primeiras letras. A palavra não apareceu no _Webster’s New World Dictionary_ até 1957; encontramos apenas a forma mais antiga “algorismo” com seu significado antigo, o processo de fazer aritmética usando numerais arábicos. Durante a Idade Média, os abacistas computavam no ábaco e os algoristas computavam por algorismo. Na época do Renascimento, a origem desta palavra era incerta, e os primeiros linguistas tentaram adivinhar sua derivação fazendo combinações com _algiros_ [doloroso] + arithmos [número]; outros disseram que não, a palavra vem de “Rei Algor de Castela”. Finalmente, os historiadores da matemática encontraram a verdadeira origem da palavra algorismo: vem do nome de um famoso autor de livros didáticos persa, Abū ‘Abd Allāh Muḥammad ibn Mūsā al-Khwārizmī (c. 825)—literalmente, “Pai de Abdullah, Mohammed, filho de Moisés, nativo de Khwārizm.” O Mar de Aral na Ásia Central já foi conhecido como Lago Khwārizm, e a região de Khwārizm está localizada na bacia do rio Amu, ao sul desse mar. Al-Khwārizmī escreveu o célebre texto árabe _Kitāb al-jabr wa’l-muqābala_ (“Regras de restauração e equação”); outra palavra, “álgebra”, deriva do título desse livro, que era um estudo sistemático da solução de equações lineares e quadráticas. [Para notas sobre a vida e obra de al-Khwārizmī, veja H. Zemanek, Lecture Notes in Computer Science **122** (1981), 1–81.]

Gradualmente, a forma e o significado de algorismo foram se corrompendo; conforme explicado pelo _Oxford English Dictionary_, a palavra “passou por muitas perversões pseudo-etimológicas, incluindo a recente _algoritmo_, na qual é eruditamente confundida” com a raiz grega da palavra _aritmética_. Esta mudança de “algorismo” para “algoritmo” não é difícil de entender, dado que as pessoas tinham esquecido a derivação original da palavra. Um dos primeiros dicionários matemáticos alemães, _Vollständiges mathematisches Lexicon_ (Leipzig: 1747), deu a seguinte definição para a palavra _Algorithmus_: “Sob esta designação estão combinadas as noções dos quatro tipos de cálculos aritméticos, a saber, adição, multiplicação, subtração e divisão.” A frase em latim _algorithmus infinitesimalis_ era na época usada para denotar “modos de cálculo com quantidades infinitamente pequenas, conforme inventado por Leibniz.”

Em 1950, a palavra algoritmo estava mais frequentemente associada ao algoritmo de Euclides, um processo para encontrar o maior divisor comum de dois números que aparece nos *Elementos de Euclides* (Livro 7, Proposições 1 e 2). Será instrutivo apresentar o algoritmo de Euclides aqui:

---
**Algoritmo E** (*algoritmo de Euclides*).

Dado dois números inteiros positivos *$$m$$* e *$$n$$*, encontre *o maior divisor comum*, ou seja, o maior número inteiro positivo que divide ambos *$$m$$* e *$$n$$* sem deixar resto.

**$$E1$$.** [Encontrar o resto] Divida *$$m$$* por *$$n$$* e deixe *$$r$$* ser o resto. (Ou seja, 0 ≤ *$$r$$* < *$$n$$*.)

**$$E2$$.** [É zero?] Se *$$r$$* = 0, o algoritmo termina; *$$n$$* é a resposta (o MDC de *$$m$$* e *$$n$$*).

**$$E3$$.** [Reduzir] Defina *$$m$$* ← *$$n$$*, *$$n$$* ← *$$r$$* e volte para a etapa **$$E1$$.** **||**

---

Claro, Euclides não apresentou seu algoritmo exatamente dessa forma. O formato acima foi adotado para ilustrar o estilo de apresentação dos algoritmos ao longo deste livro.

Cada algoritmo recebe uma letra identificadora (como o "E" no exemplo anterior), e os passos do algoritmo são numerados, seguindo essa letra ($$E1$$, $$E2$$, $$E3$$). Os capítulos são divididos em seções numeradas e, dentro de uma seção, os algoritmos são designados apenas pela letra. Quando referenciados em seções posteriores, o número da seção correspondente é anexado. Por exemplo, estamos na Seção 1.1; dentro dessa seção, o algoritmo de Euclides é chamado de "Algoritmo E", mas em seções futuras será referido como "Algoritmo 1.1E".

Cada passo de um algoritmo, como o $$E1$$, começa com uma frase resumida entre colchetes, que sintetiza seu conteúdo principal de forma concisa. Essa frase geralmente aparece também em um fluxograma complementar, como mostrado na Figura 1, para facilitar a visualização do algoritmo pelo leitor.

![**Fig. 1**. Fluxograma para o Algoritimo E.](/assets/images/volume-1/fig-1.png)


Após a frase de resumo, segue uma descrição, em palavras e símbolos, de uma ação a ser executada ou decisão a ser tomada. Comentários entre parênteses, como o da segunda frase no passo $$E1$$, também podem ser incluídos. Esses comentários servem como explicações adicionais sobre o passo, frequentemente destacando características invariantes das variáveis ou os objetivos atuais. Eles não especificam ações que fazem parte do algoritmo, mas são destinados ao leitor como auxiliares para uma melhor compreensão.

A seta "←", presente no passo $$E3$$, representa a operação de *substituição*, também chamada de *atribuição*. Por exemplo, "$$m$$ ← $$n$$" significa que o valor da variável $$m$$ será substituído pelo valor atual de $$n$$. Quando o Algoritmo E começa, $$m$$ e $$n$$ possuem valores iniciais predefinidos; ao final do algoritmo, esses valores podem ter mudado. A seta "←" é utilizada para distinguir a substituição da igualdade. Não diríamos "Atribua $$m$$ = $$n$$", mas, talvez, perguntaríamos "$$m$$ = $$n$$?". O símbolo "=" denota uma condição a ser verificada, enquanto "←" indica uma ação a ser executada. A operação de aumentar $$n$$ em um é representada por "$$n$$ ← $$n$$ + 1" (lido como "$$n$$ recebe $$n$$ + 1" ou "$$n$$ é substituído por $$n$$ + 1"). Em termos gerais, "variável ← fórmula" significa que a fórmula deve ser calculada com base nos valores atuais das variáveis envolvidas, e o resultado deve substituir o valor anterior da variável à esquerda da seta. Pessoas não familiarizadas com computação podem, às vezes, dizer "$$n$$ se torna $$n$$ + 1" ou usar "$$n$$ → $$n$$ + 1" para essa operação, mas isso pode causar confusão, pois entra em conflito com as convenções padrões e deve ser evitado. Vale ressaltar que a ordem das ações no passo $$E3$$ é crucial: "Atribua $$m$$ ← $$n$$, $$n$$ ← $$r$$" é diferente de "Atribua $$n$$ ← $$r$$, $$m$$ ← $$n$$", pois a segunda sequência faria com que o valor anterior de $$n$$ se perdesse antes de ser usado para atribuir $$m$$. Assim, a segunda sequência equivale a "Atribua $$n$$ ← $$r$$, $$m$$ ← $$r$$". Quando várias variáveis devem receber o mesmo valor, podemos usar múltiplas setas; por exemplo, "$$n$$ ← $$r$$, $$m$$ ← $$r$$" pode ser simplificado como "$$n$$ ← $$m$$ ← $$r$$". Para trocar os valores de duas variáveis, usamos "Troque $$m$$ ↔ $$n$$", ou alternativamente, podemos usar uma variável temporária t: "Atribua t ← $$m$$, $$m$$ ← $$n$$, $$n$$ ← t".

Um algoritmo começa pelo passo de menor número, geralmente o passo 1, e segue a execução sequencial dos passos subsequentes, salvo indicação em contrário. No passo $$E3$$, o comando "volte para o passo $$E1$$" define claramente a ordem computacional. No passo $$E2$$, a ação é precedida pela condição "Se $$r = 0$$"; portanto, se $$r ≠ 0$$, a parte seguinte dessa sentença não será executada. Para maior clareza, poderíamos adicionar a frase redundante: "Se $$r ≠ 0$$, vá para o passo $$E3$$."

A linha vertical pesada **||** no final do passo $$E3$$ indica o término do algoritmo e o retorno ao texto. Já discutimos quase todas as convenções notacionais usadas nos algoritmos deste livro, exceto uma notação que denota elementos "subscritos" ou "indexados", ou seja, itens de um vetor ordenado. Suponhamos que tenhamos $$n$$ quantidades, $$v_1$$, $$v_2$$,$$...$$,$$v_n$$; em vez de escrever $$v_j$$ para o $$j$$-ésimo elemento, frequentemente usamos a notação $$v[j]$$. Da mesma forma, a notação $$a[i, j]$$ pode ser preferida em vez de uma notação duplamente subscrita, como $$a_{ij}$$. Também são usados nomes de variáveis compostos, geralmente em letras maiúsculas; por exemplo, $$TEMP$$ pode ser o nome de uma variável para armazenar temporariamente um valor calculado, e $$PRIME[K]$$ pode denotar o $$K$$-ésimo número primo, entre outros.

Agora que entendemos a estrutura dos algoritmos, vamos executar um. Antes de prosseguir, é importante destacar que um algoritmo não deve ser lido como um romance; tentar fazê-lo tornaria sua compreensão mais difícil. Para realmente entender um algoritmo, é preciso vê-lo em ação. A melhor forma de aprender é experimentando: o leitor deve pegar lápis e papel e resolver um exemplo assim que encontrar um novo algoritmo no texto. Geralmente, um esboço de exemplo será fornecido, mas, caso contrário, é fácil criar um. Esse método simples e eficiente facilita a compreensão, enquanto outras abordagens costumam falhar.  

Vamos então trabalhar com um exemplo do Algoritmo E. Suponha que temos $$ m = 119 $$ e $$ n = 544 $$. Começamos pelo passo E1. (O leitor deve acompanhar o algoritmo enquanto detalhamos cada etapa.) A divisão de $$ m $$ por $$ n $$ aqui é trivial, pois o quociente é zero e o resto é 119, então $$ r \leftarrow 119 $$. No passo E2, como $$ r \neq 0 $$, seguimos adiante. No passo E3, atualizamos os valores: $$ m \leftarrow 544 $$ e $$ n \leftarrow 119 $$.  

Se originalmente tivéssemos $$ m < n $$, o quociente no passo E1 seria sempre zero, e o algoritmo prosseguiria com a troca de $$ m $$ e $$ n $$. Para evitar essa redundância, poderíamos adicionar um novo passo inicial:  

**E0. [Garantir que $$ m \geq n $$.]**  
Se $$ m < n $$, trocar $$ m \leftrightarrow n $$.  

Essa modificação não alteraria a essência do algoritmo, mas reduziria seu tempo de execução em aproximadamente metade dos casos, ainda que aumentasse ligeiramente seu comprimento.  

Retornando ao passo E1, temos:  

$$544 \div 119 = 4 + \frac{68}{119}, \quad \text{portanto, } r \leftarrow 68$$


No passo E2, como $$ r \neq 0 $$, seguimos para o passo E3: $$ m \leftarrow 119 $$, $$ n \leftarrow 68 $$. A próxima iteração nos dá $$ r \leftarrow 51 $$, depois $$ m \leftarrow 68 $$, $$ n \leftarrow 51 $$, em seguida $$ r \leftarrow 17 $$, com $$ m \leftarrow 51 $$, $$ n \leftarrow 17 $$. Finalmente, quando $$ 51 $$ é dividido por $$ 17 $$, obtemos $$ r \leftarrow 0 $$, encerrando o algoritmo no passo E2. Assim, o maior divisor comum de 119 e 544 é **17**.  

Isso é um algoritmo. O termo moderno se assemelha a conceitos como receita, processo, método, técnica, procedimento ou rotina, mas carrega uma nuance própria. Um algoritmo não é apenas um conjunto finito de regras que define uma sequência de operações para resolver um problema específico. Ele possui cinco características essenciais:  

1) **Finitude** – Um algoritmo deve sempre terminar após um número finito de passos. O Algoritmo E atende a essa condição, pois, após cada execução do passo E1, o valor de $$ r $$ é sempre menor que $$ n $$. Se $$ r \neq 0 $$, $$ n $$ diminui na próxima iteração. Como estamos lidando com uma sequência decrescente de números inteiros positivos, o processo necessariamente termina após um número finito de passos.  

---

O texto agora está mais fluido, mantendo o rigor técnico. Ele também melhora a legibilidade, eliminando construções desnecessariamente complicadas.